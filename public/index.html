<!DOCTYPE html>
<html lang="zh" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.141.0"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Lei 的博客</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://zzhaolei.github.io/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0957b579b0279552dcacb4ca66f82650340a0d99a4bd6a3752490f441fe3e1ec.css" integrity="sha256-CVe1ebAnlVLcrLTKZvgmUDQKDZmkvWo3UkkPRB/j4ew=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zzhaolei.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zzhaolei.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zzhaolei.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zzhaolei.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zzhaolei.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://zzhaolei.github.io/index.xml">
<link rel="alternate" type="application/json" href="https://zzhaolei.github.io/index.json">
<link rel="alternate" hreflang="zh" href="https://zzhaolei.github.io/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://zzhaolei.github.io/">
  <meta property="og:site_name" content="Lei 的博客">
  <meta property="og:title" content="Lei 的博客">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lei 的博客">
<meta name="twitter:description" content="">

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Lei 的博客",
  "url": "https://zzhaolei.github.io/",
  "description": "",
  "logo": "https://zzhaolei.github.io/favicon.ico",
  "sameAs": [
      "https://github.com/zzhaolei"
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zzhaolei.github.io/" accesskey="h" title="Lei 的博客 (Alt + H)">Lei 的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zzhaolei.github.io/archive/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://zzhaolei.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://zzhaolei.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<article class="first-entry home-info">
    <header class="entry-header">
        <h1>Lei 的博客</h1>
    </header>
    <div class="entry-content">
        (ง•_•)ง
    </div>
    <footer class="entry-footer">
        <div class="social-icons" >
    <a href="https://github.com/zzhaolei" target="_blank" rel="noopener noreferrer me"
        title="Github">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg>
    </a>
</div>

    </footer>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">记录常用的各种工具
    </h2>
  </header>
  <div class="entry-content">
    <p>用于Go项目 名称 描述 gopkgview 交互式的基于Web的Go包依赖图可视化 gup 更新由go install安装的二进制文件 gsa 分析编译后的Go二进制文件大小的工具，可以清晰的了解每个包或依赖在二进制中占用的大小 mockgen gomock是Go编程语言的模拟框架 nilaway 静态分析工具，用于检测Go代码中的潜在nil恐慌 命令行 名称 描述 bat cat的现代替代品 curlie curl的力量，httpie的使用便捷性 croc 轻松安全地将内容从一台计算机发送到另一台计算机 difft 结构化差异，理解语法。也可用于git diff direnv 加载或卸载当前目录（以及目录）的.envrc或.env fastfetch 功能丰富、面向性能、类似 neofetch 的系统信息工具 fd find的现代替代品 fzf 命令行模糊查找器 grpcurl 与cURL类似，但针对gRPC：与gRPC服务器交互的命令行工具 htop top的替代品。一个交互式流程查看器 hyperfine 命令行基准测试工具 jq 命令行JSON处理器 lsd ls的现代替代品 mycli MySQL自动补全和语法高亮的终端客户端 ouch 支持多种格式的压缩和解压缩，tar、zip、7z、gz、rar等 pgcli Postgres自动补全和语法高亮的终端客户端 rg 一个面向行的搜索工具，它递归地搜索当前目录中的正则表达式模式 scc 一个类似于cloc、sloccount和tokei的工具。用于统计多种编程语言的代码行数、空白行、注释行和源代码的物理行数 sd sed的现代替代品 vivid 具有丰富文件类型数据库的主题化LS_COLORS生成器 zoxide 更智能的cd命令，支持jump App 名称 描述 iina 适用于macOS的现代视频播放器 mac-mouse-fix macOS平滑滚动 </p>
  </div>
  <footer class="entry-footer"><span title='2024-11-25 10:20:20 +0800 CST'>2024-11-25</span>&nbsp;·&nbsp;1 分钟</footer>
  <a class="entry-link" aria-label="post link to 记录常用的各种工具" href="https://zzhaolei.github.io/posts/%E8%AE%B0%E5%BD%95%E5%B8%B8%E7%94%A8%E7%9A%84%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">十亿行挑战
    </h2>
  </header>
  <div class="entry-content">
    <p> 十亿行挑战（1️⃣🐝🏎️ The One Billion Row Challenge）
原始仓库
目标 文本文件包含了一系列气象站的温度值。 每行是一个测量值，格式为&lt;string: station name&gt;;&lt;double: measurement&gt;，其中测量值精确到一位小数。以下是一些示例行：
1 2 3 4 5 6 7 8 9 10 Hamburg;12.0 Bulawayo;8.9 Palembang;38.8 St. John&#39;s;15.2 Cracow;12.6 Bridgetown;26.9 Istanbul;6.2 Roseau;34.4 Conakry;31.2 Istanbul;23.0 任务是编写一个程序，该程序读取文本文件，计算每个气象站的最低、平均和最高温度值，并将结果输出到stdout， 格式如下（按气象站名称字母顺序排序，并且每个气象站的结果值格式为&lt;min&gt;/&lt;mean&gt;/&lt;max&gt;，保留一位小数点）：
1 {Abha=-23.0/18.0/59.2, Abidjan=-16.2/26.0/67.3, Abéché=-10.0/29.4/69.0, Accra=-10.1/26.4/66.4, Addis Ababa=-23.7/16.0/67.0, Adelaide=-27.8/17.3/58.5, ...} 限制 只能使用标准库实现。
生成十亿行挑战所需的数据 克隆原始仓库：
1 2 3 4 git clone https://github.com/gunnarmorling/1brc cd 1brc/src/main/python python3 create_measurements.py 1000000000 生成的数据会在1brc/measurements.txt，约为15Gi的大小。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-11-23 15:49:21 +0800 CST'>2024-11-23</span>&nbsp;·&nbsp;4 分钟</footer>
  <a class="entry-link" aria-label="post link to 十亿行挑战" href="https://zzhaolei.github.io/posts/%E5%8D%81%E4%BA%BF%E8%A1%8C%E6%8C%91%E6%88%98/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Go 在 Mac 或 Linux 上构建动态库
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 可以导出 C ABI，然后在其它兼容 C ABI 的语言中调用。
下面详细讲解一下用法：
Go 构建动态库 定义一个 go 文件，包含以下代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import &#34;C&#34; //export Add func Add(a, b int) int { return a &#43; b } //export Multiply func Multiply(a, b int) int { return a * b } func main() {} go 的文件名称在当前示例中无关紧要，这里定义为 main.go。
main 函数是必须的，但是可以为空。
注意：代码中的 //export Add 表示导出 Add 函数，export 和 // 之间没有空格。这是 Go 中的一种特殊指令，类似的还有 //go:build 等。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-11 10:55:43 +0800 CST'>2024-09-11</span>&nbsp;·&nbsp;2 分钟</footer>
  <a class="entry-link" aria-label="post link to Go 在 Mac 或 Linux 上构建动态库" href="https://zzhaolei.github.io/posts/go-%E5%9C%A8-mac-%E6%88%96-linux-%E4%B8%8A%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81%E5%BA%93/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Rust main 函数是如何被执行的
    </h2>
  </header>
  <div class="entry-content">
    <p>Rust main 函数到底是如何被执行的呢？ 让我们看一个关于 main 函数的示例：
1 2 3 4 5 6 use std::error::Error; fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { println!(&#34;hello world&#34;); Ok(()) } 从这个示例我们可以看到，rust 的 main 函数竟然还可以返回 Result 枚举，这是为什么？rust 到底是如何执行用户定义的 main 函数的呢？
接下来让我们对 rust 的源码进行剖析，看一看 rust 到底是如何运行 main 函数的。
Rust 运行时 首先，在几乎所有的语言中（目前我不知道哪个语言会不进行处理），在执行用户的 main 函数之前都需要进行一些初始化工作，比如分配堆栈、创建并绑定主线程、初始化通用寄存器、初始化 GC等等。
而 rust 也不例外，也会在实际调用用户执行的 main 之前进行一些初始化的操作。
你没看错，rust 也是有运行时的，只不过这个运行时没有 GC，非常的轻量级，主要是执行上面所说的初始化操作以及对 main 函数的执行和收尾。
让我们先从 init 开始：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 在执行 main 之前执行 unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) { #[cfg_attr(target_os = &#34;teeos&#34;, allow(unused_unsafe))] unsafe { // 实际的资源初始化逻辑 sys::init(argc, argv, sigpipe) }; // 设置主线程，并设置一个名字 let thread = Thread::new_main(); thread::set_current(thread); } // 运行时只会执行一次 cleanup。 // 在 main 或程序退出的时候执行 // NOTE: 当程序被终止的时候，不能保证执行 cleanup // （终止是 kill 等强制终止，或段错误等行为，程序无法继续执行，资源由操作系统进行回收） pub(crate) fn cleanup() { static CLEANUP: Once = Once::new(); CLEANUP.call_once(|| unsafe { // 刷新 stdout 缓冲区的数据，并禁用缓冲区 crate::io::cleanup(); // SAFETY: 通过 Once 保证，只会执行一次 cleanup sys::cleanup(); }); } 系统资源的初始化和清理在 sys::init 和 sys::cleanup 中 sys::init 在 ffi 中不保证被调用 sys::init 的源码不是算复杂，主要是保证打开标准输入输出流、初始化栈，感兴趣的可以自行阅读源码 现在我们终于可以进入重点了，rust 对 main 函数的处理逻辑：
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-01 10:20:00 +0800 CST'>2024-09-01</span>&nbsp;·&nbsp;4 分钟</footer>
  <a class="entry-link" aria-label="post link to Rust main 函数是如何被执行的" href="https://zzhaolei.github.io/posts/rust-main-%E5%87%BD%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%89%A7%E8%A1%8C%E7%9A%84/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">使用AWS S3 SDK访问阿里云oss
    </h2>
  </header>
  <div class="entry-content">
    <p> 目前业务上使用的是 aws 的 s3 服务，但是想兼容阿里云的 oss。根据oss的文档描述，oss支持使用 aws 的 sdk 进行访问，所以记录一下处理流程 访问AWS S3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package main import ( &#34;context&#34; &#34;log&#34; &#34;os&#34; &#34;github.com/aws/aws-sdk-go-v2/aws&#34; &#34;github.com/aws/aws-sdk-go-v2/config&#34; &#34;github.com/aws/aws-sdk-go-v2/credentials&#34; &#34;github.com/aws/aws-sdk-go-v2/service/s3&#34; ) func NewS3Client() *s3.Client { accessKeyID := os.Getenv(&#34;ACCESS_KEY_ID&#34;) accessKeySecret := os.Getenv(&#34;ACCESS_KEY_SECRET&#34;) cfg, err := config.LoadDefaultConfig( context.TODO(), config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(accessKeyID, accessKeySecret, &#34;&#34;)), config.WithEndpointResolverWithOptions( aws.EndpointResolverWithOptionsFunc(func(_, _ string, _ ...interface{}) (aws.Endpoint, error) { return aws.Endpoint{ PartitionID: &#34;aws-cn&#34;, URL: &#34;https://s3.cn-northwest-1.amazonaws.com.cn&#34;, SigningRegion: &#34;cn-northwest-1&#34;, }, nil }), ), ) if err != nil { log.Fatal(err) } return s3.NewFromConfig(cfg, func(o *s3.Options) { // 此选项可用于调试 // o.ClientLogMode = aws.LogSigning | aws.LogRequest | aws.LogResponseWithBody o.UsePathStyle = true }) } func main() { bucket := os.Getenv(&#34;S3_BUCKET&#34;) uploadKey := os.Getenv(&#34;S3_KEY&#34;) file, _ := os.Open(&#34;test.txt&#34;) client := NewS3Client() _, err := client.PutObject(context.Background(), &amp;s3.PutObjectInput{ Bucket: aws.String(bucket), Key: aws.String(uploadKey), Body: file, }) if err != nil { log.Fatal(err) } } 这是一个简单的 s3 文件上传，通过在 PutObjectInput 中指定Bucket 参数的形式。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-01 10:14:00 +0800 CST'>2024-09-01</span>&nbsp;·&nbsp;3 分钟</footer>
  <a class="entry-link" aria-label="post link to 使用AWS S3 SDK访问阿里云oss" href="https://zzhaolei.github.io/posts/%E4%BD%BF%E7%94%A8aws-s3-sdk%E8%AE%BF%E9%97%AE%E9%98%BF%E9%87%8C%E4%BA%91oss/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">通过docker配置MySQL主从服务
    </h2>
  </header>
  <div class="entry-content">
    <p>目录结构 1 2 3 4 5 6 . ├── master │ └── my.cnf ├── slave │ └── my.cnf └── docker-compose.yml master：主配置
slave：从配置
docker-compose：通过 docker-compose 进行容器配置和启动
master/my.cnf
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # For advice on how to change settings please see # http://dev.mysql.com/doc/refman/8.3/en/server-configuration-defaults.html [mysqld] host-cache-size=0 skip-name-resolve datadir=/var/lib/mysql socket=/var/run/mysqld/mysqld.sock secure-file-priv=/var/lib/mysql-files user=mysql pid-file=/var/run/mysqld/mysqld.pid # 自定义部分 log-bin=master-bin binlog-format=row # row 按行重放，statement 重放 sql 语句，mixed 默认基于 statement，一旦发现基于 sql 无法精准重放时，会使用 row，MySQL 默认是基于 statement 的复制 binlog-do-db=test # 开启 binlog 的数据库名，如果有多个数据库，那么可以重复设置 server-id=1 # server-id 不能和任何 主或从 重复 # 自定义部分 [client] socket=/var/run/mysqld/mysqld.sock !includedir /etc/mysql/conf.d/ slave/my.cnf 和 master/my.cnf 内容基本一致，但是 server-id 不能重复
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-01 10:13:00 +0800 CST'>2024-09-01</span>&nbsp;·&nbsp;4 分钟</footer>
  <a class="entry-link" aria-label="post link to 通过docker配置MySQL主从服务" href="https://zzhaolei.github.io/posts/%E9%80%9A%E8%BF%87docker%E9%85%8D%E7%BD%AEmysql%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Go设计模式——单例模式
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 单例模式同时解决了两个问题：
保证一个类只有一个实例，例如控制某些共享资源（如数据库或文件）的访问权限 为该实例提供一个全局访问节点 在Go中单例模式有两种实现，一种是饿汉式，一种是懒汉式。饿汉式简单，可以将问题及早暴露出来，懒汉式虽然支持延迟加载，但是也将可能的问题延迟到了第一次调用的时候，同时为了实现并发安全，也不得不加锁。
饿汉式 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Package singleton package singleton // singleton 饿汉式 var singleton *File type File struct{} func init() { singleton = &amp;File{} } func GetInstance() *File { return singleton } 单元测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package tests import ( &#34;testing&#34; &#34;design-pattern/singleton&#34; &#34;github.com/stretchr/testify/assert&#34; ) // TestSingleton 测试单例 func TestInstance(t *testing.T) { assert.Equal(t, singleton.GetInstance(), singleton.GetInstance()) } // BenchmarkSingleton 测试并发访问单例 func BenchmarkInstance(b *testing.B) { b.RunParallel(func(p *testing.PB) { for p.Next() { assert.Equal(b, singleton.GetInstance(), singleton.GetInstance()) } }) } 懒汉式 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // Package lazysingleton 懒汉式单例 package lazysingleton import &#34;sync&#34; var ( lazySingleton *File once sync.Once ) type File struct{} func GetLazyInstance() *File { if lazySingleton == nil { // 使用sync.Once来确保单例在并发时只被初始化一次 once.Do(func() { lazySingleton = &amp;File{} }) } return lazySingleton } 单元测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package tests import ( &#34;testing&#34; &#34;design-pattern/lazysingleton&#34; &#34;github.com/stretchr/testify/assert&#34; ) // TestLazySingleton 测试懒汉式单例 func TestLazyInstance(t *testing.T) { assert.Equal(t, lazysingleton.GetLazyInstance(), lazysingleton.GetLazyInstance()) } // BenchmarkGetLazyInstance 测试懒汉式单例 func BenchmarkGetLazyInstance(b *testing.B) { b.RunParallel(func(p *testing.PB) { for p.Next() { assert.Equal(b, lazysingleton.GetLazyInstance(), lazysingleton.GetLazyInstance()) } }) } 测试结果 1 2 3 4 5 6 7 8 ❯ go test -bench . goos: darwin goarch: arm64 pkg: design-pattern/tests BenchmarkGetLazyInstance-8 3113553	380.8 ns/op BenchmarkInstance-8 3156261	378.5 ns/op PASS ok design-pattern/tests	3.798s 根据bench结果可以发现加锁（sync.Once内部使用的atomic来进行处理）还是会对性能造成影响的，不过也在可接受范围内。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-01 10:12:00 +0800 CST'>2024-09-01</span>&nbsp;·&nbsp;2 分钟</footer>
  <a class="entry-link" aria-label="post link to Go设计模式——单例模式" href="https://zzhaolei.github.io/posts/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Go设计模式——开闭原则
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 简单的说就是：对扩展开放，对修改关闭。对扩展开放是为了应对需求的变化，对修改关闭就是为了保证已有代码的稳定性，最终是为了让系统更具有弹性，能更好的处理需求。
开闭原则也包含了单一职责原则。
我们以消息队列来进行举例。
坏的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Package main 开闭原则 Open-Closed Principle // 开闭原则包含了：单一职责原则 package main import &#34;fmt&#34; type KafkaQueue struct{} func (k *KafkaQueue) SendMSG(msg string) error { fmt.Println(&#34;Kafka send msg success&#34;) return nil } type RabbitQueue struct{} func (r *RabbitQueue) SendMSG(msg string) error { fmt.Println(&#34;Rabbitmq send msg success&#34;) return nil } type Demo struct{} func (d *Demo) SendByKafka(queue KafkaQueue, msg string) error { return queue.SendMSG(msg) } func (d *Demo) SendByRabbit(queue RabbitQueue, msg string) error { return queue.SendMSG(msg) } func main() { } 通过这个例子，我们可以看出来，这段代码违背了我们的对扩展开放，对修改关闭的原则。当我们需要添加一个新的RocketMQ的时候，需要改动Demo的逻辑以及其他设计的业务逻辑，可扩展性可以说是一点也没有。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-01 10:11:00 +0800 CST'>2024-09-01</span>&nbsp;·&nbsp;2 分钟</footer>
  <a class="entry-link" aria-label="post link to Go设计模式——开闭原则" href="https://zzhaolei.github.io/posts/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Go设计模式——单一职责原则
    </h2>
  </header>
  <div class="entry-content">
    <p>介绍 类的职责应该是单一的，对外只提供一种功能，而引起类变化的原因应该只有一个。简单的说就是每一个类只负责自己的事情，只有单一的功能。
我们现在以银行工作人员举例：
坏的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Package main 单一职责原则 Single-Responsibility Principle package main import &#34;fmt&#34; type Banker struct{} // Save 存钱 func (b *Banker) Save(money uint64) error { fmt.Printf(&#34;成功存入: %d\n&#34;, money) return nil } // Transfer 转账 func (b *Banker) Transfer(money uint64, to string) error { fmt.Printf(&#34;成功向: %s转入: %d\n&#34;, to, money) return nil } 单一职责原则要求一个类/接口只有一个职责，而引起类变化的原因只能有一个。
从原则上讲，我们为Banker定义存钱和转账的操作是有道理的，因为我们接口中定义的都是银行工作人员可以执行的操作，引起变化的原因只能是Banker的属性和行为发生变化。
从这方便考虑，这种设计是有合理性的，如果能保证需求不会变化或者需求变化的可能行很小，那么这种设计就是合理的。
但是实际上我们知道，需求是不断变化的，今日增加一个股票业务，那么我们就需要增加一个股票的相关属性和行为，我们的接口和实现就需要全部变动。
最好的方式就是当我们开始定义的时候，根据属性和行为进行细分，抽象不同的接口出来，在Go里面也是主张小接口，这样我们可以通过组合的手段来随意构造我们想要的大接口。
好的 我们将Banker进行抽象，这样可以更好的进行扩展：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Package main 单一职责原则 Single-Responsibility Principle package main import &#34;fmt&#34; type Config struct { Money uint64 To string } type Banker interface { DoSomething(Config) error } type SaveBanker struct{} func (sb *SaveBanker) DoSomething(cfg Config) error { fmt.Printf(&#34;成功存入: %d\n&#34;, cfg.Money) return nil } type TransferBanker struct{} func (tb *TransferBanker) DoSomething(cfg Config) error { fmt.Printf(&#34;成功向: %s转入: %d\n&#34;, cfg.To, cfg.Money) return nil } 我们抽象出来了Banker接口，每一个不太的业务员都可以实现这个接口，对行为进行自定义。
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-01 10:10:00 +0800 CST'>2024-09-01</span>&nbsp;·&nbsp;1 分钟</footer>
  <a class="entry-link" aria-label="post link to Go设计模式——单一职责原则" href="https://zzhaolei.github.io/posts/go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">如何在Go中使用POSIX命名信号量
    </h2>
  </header>
  <div class="entry-content">
    <p>go 本身提供的 semaphore 只能在同一个进程多个协程或线程间使用，无法在不同的 go 进程之间使用，所以本文介绍，如何使用 go 中的 syscall 来使用 POSIX 系统提供的命名信号量。
Go 中的系统调用 在 go 中，系统调用是通过 syscall 包提供的 Syscall 函数来进行系统调用的，不同的系统调用有不同的 trap，以及不同长度的参数。
trap go 在 syscall 包中定义了大量的系统调用码，具体定义在文件1.20.6/go/src/syscall/zsysnum_darwin_arm64.go 。不同操作系统上，定义所使用的文件是不同的，这些定义都是通过不同系统的c 语言头文件自动生成的。比如 linux amd64 操作系统的定义在1.20.6/go/src/syscall/zerrors_linux_amd64.go。
不同长度的参数 syscall 包有 Syscall、Syscall6 两个函数，对应于不同的操作系统调用参数长度的情况。
Syscall 总共接收 4 个参数，第一个是 trap 定义，描述具体的系统调用，剩下的 3 个是系统调用所需的参数。
Syscall6 总共接收 7 个参数，第一个是 trap 定义，描述具体的系统调用，剩下的 6 个是系统调用所需的参数。
如果使用 Syscall 或 Syscall6 时，系统调用所需的参数不满足函数形参所需的数量，则剩下的参数传0。
例如，在 POSIX 系统上打开一个命名信号量的系统调用是:
1 sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); 因为系统调用的参数有 4 个，而 Syscall 接收的全部形参才 4 个，所以 Syscall 不能满足我们的需求，只能使用 Syscall6 这个函数。而 Syscall6 总共需要 7 个形参，其中有 6 个是系统调用参数，我们只有 4 个系统调用参数，那么剩下的 2 个系统调用参数，我们就可以使用 0 替代，例如：
...</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-01 10:09:00 +0800 CST'>2024-09-01</span>&nbsp;·&nbsp;3 分钟</footer>
  <a class="entry-link" aria-label="post link to 如何在Go中使用POSIX命名信号量" href="https://zzhaolei.github.io/posts/%E5%A6%82%E4%BD%95%E5%9C%A8go%E4%B8%AD%E4%BD%BF%E7%94%A8posix%E5%91%BD%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://zzhaolei.github.io/page/2/">下一页&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://zzhaolei.github.io/">Lei 的博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
